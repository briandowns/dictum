#!/usr/bin/env dictu

import Env;
import HTTP;
import JSON;
import Path;
import Process;
import System;

from Argparse import Parser;


const version = "v0.1.0",
      usage = "Usage: dictum <command> <args>

Options:
    install       install the given module
    uninstall     uninstall the given module
    create        create a packaged module
    info          get info for an installed module
    help          help menu
    version       version information

Examples: 
    dictum install slog.tgz
    dictum info slog
";

const localMods = "dictu_modules",
      modDataFile = "dictum.json",
      modsConfigPath = "{}/.dictu";

/**
 * setupEnv checks for needed directories and creates them
 * if they don't exist.
 */
def setupEnv() {
    if (not Path.exists(localMods)) {
        System.mkdirAll(localMods);
    }

    if (not Path.exists(localMods)) {
        System.mkdirAll(localMods);
    }
}

/**
 * findModule searches the user home paths for the 
 * given module.
 */
def findModule(name) {
    if (Path.exists("{}/{}".format(localMods, name))) {
        return Success("{}/{}".format(localMods, name));
    }

    return Error("{} not found".format(name));
}

/**
 * parseModuleConfig receives a for the given module,
 * reads the config file, and returns the JSON.
 */
def parseModuleConfig() {
    const versionFile = localMods + Path.dirSeparator + modDataFile;

    with(versionFile, "r") {
        return config = JSON.parse(file.read()).match(
            def(result) => result, 
            def(error) => {
                print(error);
                return;
            }
        );
    }
}

/**
 * validDictumJson checks to see if the given JSON
 * contains the required fields.
 */
def validDictumJson(dictumFile) {
    var modConfig;

    with(dictumFile, 'r') {
        modConfig = JSON.parse(file.read()).unwrap();
    }

    if (not modConfig.exists("name")) {
        return Error("error: missing 'name' field");
    }

    if (not modConfig.exists("version")) {
        return Error("error: missing 'version' field");
    }

    return Success(nil);
}

/**
 * loadConfig generates the base config from file and returns
 * a dictionary for use in the app.
 */
def loadConfig() {
    var config = {
        "http": {
            "insecure": true,
            "timeout": 21
        }
    };

    const configFilePath = Path.join(modsConfigPath.format(Env.get("HOME")), "dictum_config.json");
    
    var userConfig;
    with(configFilePath, 'r') {
        userConfig = JSON.parse(file.read()).unwrap();
    }

    if (userConfig.exists("http")) {
        if (userConfig.get("http").exists("timeout")) {
            config["http"]["timeout"] = userConfig.get("http").get("timeout");
        }
        if (userConfig.get("http").exists("insecure")) {
            config["http"]["insecure"] = userConfig.get("http").get("insecure");
        }
    }

    return config;
}

{ // main
    if (System.argv.len() < 2) {
        print(usage);
        System.exit(1);
    }

    setupEnv();

    const config = loadConfig();

    switch (System.argv[1]) {
        case "install": {
            if (System.argv.len() < 3) {
                print("error: missing module name");
                System.exit(1);
            }
            
            const module = System.argv[System.argv.len()-1];
            if (not module.contains(".tgz")) {
                print("{} missing required extension (.tgz)".format(module));
                System.exit(1);
            }

            const modName = Path.basename(module).replace(".tgz", "");
            const res = findModule(modName);
            if (res.success()) {
                print("{} already installed".format(modName));
                System.exit(1);
            }

            Process.run(["tar", "xfz", "{}.tgz".format(modName), "-C", localMods], false).matchError(def(error) => {
                print(error);
                System.exit(1);
            });
        }
        case "uninstall": {
            if (System.argv.len() < 3) {
                print("error: missing module name");
                System.exit(1);
            }

            const modName = System.argv[System.argv.len()-1];
            const modPath = findModule(modName).match(
                def(result) => result,
                def(error) => {
                    print(error);
                    System.exit(1);
                }
            );

            Path.listDir(modPath).forEach(
                def(f) => { System.remove(Path.join(modPath, f)); }
            );
            
            System.rmdir(modPath);
        }
        case "create": {
            if (System.argv.len() != 3) {
                print("error: missing module name");
                System.exit(1);
            }

            const modName = System.argv[2];

            if (not Path.exists(modName) or not Path.isDir(modName)) {
                print("error: invalid module argument");
                System.exit(1);  
            }

            validDictumJson(Path.join(modName, "dictum.json")).matchError(
                def(error) => {
                    print(error);
                    System.exit(1);
                }
            );

            const fullModPath = Path.join(localMods, modName);

            Process.run(["tar", "cfz", "{}.tgz".format(modName), modName], false).matchError(def(error) => {
                print(error);
                System.exit(1);
            });

            print("module created: {}.tgz".format(modName));
        }
        case "info": {
            if (System.argv.len() != 3) {
                print("error: missing module name");
                System.exit(1);
            }

            const modName = System.argv[2];
            const modPath = findModule(modName).match(
                def(result) => result,
                def(error) => {
                    print("{} module not found".format(modName));
                    System.exit(0);
            });

            var modInfo;
            with(Path.join(modPath, modDataFile), 'r') {
                modInfo = JSON.parse(file.read()).unwrap();
            }

            print("Name:        {}".format(modInfo["name"]));
            print("Version:     {}".format(modInfo["version"]));
            print("Maintainers: {}".format(modInfo["maintainers"]["name"]));
            print("License:     {}".format(modInfo["license"]));
        }
        case "help": {
            print(usage);
        }
        case "version": {
            print("version: {}".format(version));
        }
        default: {
            print("error: unkown command {}".format(System.argv[1]));
            System.exit(1);
        }
    }

    System.exit(0);
}
